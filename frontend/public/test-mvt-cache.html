<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVT ç¼“å­˜æµ‹è¯•</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@8.2.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@8.2.0/dist/ol.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #map {
            width: 100%;
            height: 600px;
            border: 1px solid #ccc;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            margin: 5px;
            padding: 8px 16px;
        }
        .info {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>MVT ç¼“å­˜æ•°æ®æµ‹è¯•</h1>
    
    <div class="info">
        <p>è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æµ‹è¯•é¡µé¢ï¼Œç”¨äºéªŒè¯ OpenLayers åŠ è½½ç¼“å­˜çš„ MVT æ•°æ®ã€‚</p>
        <p><strong>é‡è¦æç¤ºï¼š</strong>æ­¤é¡µé¢å¿…é¡»ä¸ Vue åº”ç”¨åœ¨åŒä¸€æœåŠ¡å™¨ä¸Šè¿è¡Œæ‰èƒ½è®¿é—®ç›¸åŒçš„ IndexedDB æ•°æ®åº“ï¼</p>
        <p>å½“å‰é¡µé¢æº: <span id="current-origin"></span></p>
        <p>çŠ¶æ€: <span id="status">åˆå§‹åŒ–ä¸­...</span></p>
    </div>

    <div class="controls">
        <button onclick="checkEnvironment()">ğŸ” æ£€æŸ¥ç¯å¢ƒ</button>
        <button onclick="checkAllDatabases()">æ£€æŸ¥ç¼“å­˜æ•°æ®åº“</button>
        <button onclick="reinitializeDB()">é‡æ–°åˆå§‹åŒ–æ•°æ®åº“</button>
        <button onclick="checkCachedData()">æ£€æŸ¥ç¼“å­˜æ•°æ®</button>
        <button onclick="loadCachedData()">åŠ è½½ç¼“å­˜æ•°æ®</button>
        <button onclick="loadSpecificLayer()">é€‰æ‹©å›¾å±‚åŠ è½½</button>
        <button onclick="clearMap()">æ¸…é™¤å›¾å±‚</button>
        <button onclick="showMapInfo()">æ˜¾ç¤ºåœ°å›¾ä¿¡æ¯</button>
        <button onclick="forceRefresh()">å¼ºåˆ¶åˆ·æ–°ç“¦ç‰‡</button>
        <button onclick="showSampleData()">æ˜¾ç¤ºæ ·æœ¬æ•°æ®</button>
        <button onclick="openVueApp()">ğŸš€ æ‰“å¼€ Vue åº”ç”¨</button>
    </div>

    <div id="map"></div>

    <script>
        let map;
        let mvtLayer;
        let tileCacheService;

        // æ–°å¢ Base64 â†’ ArrayBuffer å·¥å…·å‡½æ•°
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // åˆå§‹åŒ–åœ°å›¾
        function initMap() {
            console.log('åˆå§‹åŒ–åœ°å›¾...');
            
            // è§¦å‘é‡è¯•çš„é”™è¯¯ç 
            const retryCodes = [400, 500];
            const retries = {};

            // ç“¦ç‰‡åŠ è½½äº‹ä»¶ï¼ˆç”¨äºåº•å›¾ç¼“å­˜ï¼‰
            const wmtsTileLoadFunction = function(imageTile, src) {
                const image = imageTile.getImage();
                
                // ä»URLä¸­æå–ç“¦ç‰‡åæ ‡ä¿¡æ¯ç”¨äºç¼“å­˜
                const urlPattern = /x=(\d+).*y=(\d+).*z=(\d+)/;
                const match = src.match(urlPattern);
                let layerId = 'basemap_gaode';
                let z, x, y;
                
                if (match) {
                    x = parseInt(match[1]);
                    y = parseInt(match[2]);
                    z = parseInt(match[3]);
                } else {
                    // å¦‚æœæ— æ³•è§£æåæ ‡ï¼Œç›´æ¥åŠ è½½
                    fetch(src).then(response => response.blob())
                        .then(blob => {
                            const imageUrl = URL.createObjectURL(blob);
                            image.src = imageUrl;
                        })
                        .catch(() => imageTile.setState(3));
                    return;
                }

                // æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦å·²ç»å­˜åœ¨è¯¥ç“¦ç‰‡
                if (tileCacheService) {
                    tileCacheService.getTile(layerId, z, x, y).then((tileCache) => {
                        if (tileCache != null && tileCache.data) {
                            // å¦‚æœå·²ç»å­˜åœ¨ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜çš„ç“¦ç‰‡æ›¿æ¢å›¾ç‰‡ç“¦ç‰‡
                            let imageUrl;
                            if (tileCache.data instanceof Blob) {
                                imageUrl = URL.createObjectURL(tileCache.data);
                            } else if (typeof tileCache.data === 'string') {
                                // å¦‚æœæ˜¯base64å­—ç¬¦ä¸²
                                imageUrl = 'data:image/png;base64,' + tileCache.data;
                            } else {
                                // å¦‚æœæ˜¯ArrayBuffer
                                const blob = new Blob([tileCache.data], { type: 'image/png' });
                                imageUrl = URL.createObjectURL(blob);
                            }
                            image.src = imageUrl;
                            console.log(`å‘½ä¸­åº•å›¾ç“¦ç‰‡ç¼“å­˜: ${z}/${x}/${y}`);
                            return;
                        } else {
                            // ç¼“å­˜ä¸­æ²¡æœ‰ï¼Œä»ç½‘ç»œåŠ è½½
                            fetch(src, {
                                method: 'GET',
                                keepalive: true,
                                cache: "force-cache"
                            }).then((response) => {
                                if (retryCodes.includes(response.status)) {
                                    retries[src] = (retries[src] || 0) + 1;
                                    if (retries[src] < 3) {
                                        console.log("è¯·æ±‚ç“¦ç‰‡å¤±è´¥ï¼Œé‡æ–°å°è¯•æ¬¡æ•°ï¼š" + retries[src]);
                                        setTimeout(() => imageTile.load(), retries[src] * 250);
                                    }
                                    return Promise.reject();
                                }
                                return response.blob();
                            })
                            .then((blob) => {
                                const imageUrl = URL.createObjectURL(blob);
                                image.src = imageUrl;
                                
                                // ç¼“å­˜ç“¦ç‰‡åˆ°IndexedDB
                                if (tileCacheService) {
                                    const tileData = {
                                        id: `${layerId}_${z}_${x}_${y}`,
                                        layerId: layerId,
                                        zoomLevel: z,
                                        tileX: x,
                                        tileY: y,
                                        data: blob,
                                        size: blob.size,
                                        contentType: 'image/png',
                                        timestamp: Date.now(),
                                        url: src
                                    };
                                    
                                    tileCacheService.saveTile(tileData).then(() => {
                                        console.log(`åº•å›¾ç“¦ç‰‡å·²ç¼“å­˜: ${z}/${x}/${y}`);
                                    }).catch(error => {
                                        console.error('ç¼“å­˜åº•å›¾ç“¦ç‰‡å¤±è´¥:', error);
                                    });
                                }
                            })
                            .catch(() => imageTile.setState(3)); // error
                        }
                    }).catch(error => {
                        console.error('æ£€æŸ¥ç“¦ç‰‡ç¼“å­˜å¤±è´¥:', error);
                        // ç¼“å­˜æ£€æŸ¥å¤±è´¥ï¼Œç›´æ¥ä»ç½‘ç»œåŠ è½½
                        fetch(src).then(response => response.blob())
                            .then(blob => {
                                const imageUrl = URL.createObjectURL(blob);
                                image.src = imageUrl;
                            })
                            .catch(() => imageTile.setState(3));
                    });
                } else {
                    // ç¼“å­˜æœåŠ¡æœªåˆå§‹åŒ–ï¼Œç›´æ¥ä»ç½‘ç»œåŠ è½½
                    fetch(src).then(response => response.blob())
                        .then(blob => {
                            const imageUrl = URL.createObjectURL(blob);
                            image.src = imageUrl;
                        })
                        .catch(() => imageTile.setState(3));
                }
            };

            // åˆ›å»ºé«˜å¾·åœ°å›¾åº•å›¾æº
            const gaodeSource = new ol.source.XYZ({
                url: 'https://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}',
                crossOrigin: 'anonymous',
                maxZoom: 18,
                minZoom: 3
            });

            // è®¾ç½®è‡ªå®šä¹‰ç“¦ç‰‡åŠ è½½å‡½æ•°
            gaodeSource.setTileLoadFunction(wmtsTileLoadFunction);

            // åˆ›å»ºåº•å›¾
            const baseLayer = new ol.layer.Tile({
                source: gaodeSource
            });

            //ç“¦ç‰‡åŠ è½½äº‹ä»¶ï¼ˆç”¨äºMVTç¼“å­˜ï¼‰
            const mvtTileLoadFunction = function(tile, url) {
                // å¯¹äº VectorTileï¼Œæˆ‘ä»¬éœ€è¦è®¾ç½® loader è€Œä¸æ˜¯ç›´æ¥æ“ä½œ image
                tile.setLoader(function(extent, resolution, projection) {
                    // ä»URLä¸­æå–ç“¦ç‰‡åæ ‡
                    const match = url.match(/\/(\d+)\/(\d+)\/(\d+)$/);
                    if (!match) {
                        console.warn('æ— æ³•è§£æç“¦ç‰‡åæ ‡:', url);
                        tile.setFeatures([]);
                        return;
                    }
                    
                    const [z, x, y] = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
                    console.log(`MVTç“¦ç‰‡è¯·æ±‚: ${z}/${x}/${y} - ${url}`);
                    
                    // ä»ç½‘ç»œè·å–MVTæ•°æ®
                    fetch(url)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            return response.arrayBuffer();
                        })
                        .then(arrayBuffer => {
                            // è§£æMVTæ•°æ®
                            const mvtFormat = new ol.format.MVT();
                            const features = mvtFormat.readFeatures(arrayBuffer, {
                                extent: extent,
                                featureProjection: projection
                            });
                            
                            console.log(`MVTç“¦ç‰‡ ${z}/${x}/${y} åŠ è½½æˆåŠŸï¼ŒåŒ…å« ${features.length} ä¸ªè¦ç´ `);
                            tile.setFeatures(features);
                        })
                        .catch(error => {
                            console.error(`MVTç“¦ç‰‡ ${z}/${x}/${y} åŠ è½½å¤±è´¥:`, error);
                            tile.setFeatures([]);
                        });
                });
            };
            //åˆ›å»ºMVTæº
            const mvtSource = new ol.source.VectorTile({
                url: 'http://192.168.1.17:3000/vector_8aa2a0aa/{z}/{x}/{y}',
                format: new ol.format.MVT(),
                tileLoadFunction: mvtTileLoadFunction
            });
            //åˆ›å»ºMVTå›¾å±‚
            const mvtLayer = new ol.layer.VectorTile({
                source: mvtSource,
                // æ·»åŠ æ ·å¼ä»¥ä¾¿èƒ½çœ‹åˆ°çŸ¢é‡æ•°æ®
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#FF0000',
                        width: 2
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(255, 0, 0, 0.3)'
                    }),
                    image: new ol.style.Circle({
                        radius: 5,
                        fill: new ol.style.Fill({
                            color: '#FF0000'
                        })
                    })
                })
            });

            

            // åˆ›å»ºåœ°å›¾
            map = new ol.Map({
                target: 'map',
                layers: [baseLayer, mvtLayer],
                view: new ol.View({
                    center: ol.proj.fromLonLat([106.28, 31.61]), // æ•°æ®èŒƒå›´ä¸­å¿ƒ
                    zoom: 12
                })
            });

            document.getElementById('status').textContent = 'åœ°å›¾åˆå§‹åŒ–å®Œæˆ';
            console.log('åœ°å›¾åˆ›å»ºæˆåŠŸ');
        }

        // åˆå§‹åŒ–ç¼“å­˜æœåŠ¡
        async function initCacheService() {
            try {
                // åŸºäºå®é™…çš„ indexedDBOperations.js åˆ›å»ºç“¦ç‰‡ç¼“å­˜æœåŠ¡
                class TileCacheDB {
                    constructor() {
                        this.dbName = 'TileCacheDB';
                        this.dbVersion = 1;
                        this.storeName = 'tiles';
                        this.db = null;
                    }

                    async openDB() {
                        return new Promise((resolve, reject) => {
                            if (this.db) {
                                resolve(this.db);
                                return;
                            }

                            const indexedDB = window.indexedDB || 
                                             window.mozIndexedDB || 
                                             window.webkitIndexedDB || 
                                             window.msIndexedDB;

                            if (!indexedDB) {
                                reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒ IndexedDB'));
                                return;
                            }

                            const request = indexedDB.open(this.dbName, this.dbVersion);

                            request.onsuccess = (event) => {
                                this.db = event.target.result;
                                console.log(`æ•°æ®åº“ ${this.dbName} æ‰“å¼€æˆåŠŸï¼Œç‰ˆæœ¬: ${this.db.version}`);
                                console.log(`å¯¹è±¡å­˜å‚¨:`, Array.from(this.db.objectStoreNames));
                                resolve(this.db);
                            };

                            request.onerror = (event) => {
                                console.error('ç“¦ç‰‡ç¼“å­˜æ•°æ®åº“æ‰“å¼€å¤±è´¥:', event.target.error);
                                reject(event.target.error);
                            };

                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                console.log('æ•°æ®åº“éœ€è¦å‡çº§ï¼Œæ­£åœ¨åˆ›å»ºå¯¹è±¡å­˜å‚¨...');
                                
                                if (db.objectStoreNames.contains(this.storeName)) {
                                    db.deleteObjectStore(this.storeName);
                                }

                                const objectStore = db.createObjectStore(this.storeName, {
                                    keyPath: 'id'
                                });

                                // åˆ›å»ºç´¢å¼•
                                objectStore.createIndex('layerId', 'layerId', { unique: false });
                                objectStore.createIndex('zoomLevel', 'zoomLevel', { unique: false });
                                objectStore.createIndex('tileX', 'tileX', { unique: false });
                                objectStore.createIndex('tileY', 'tileY', { unique: false });
                                objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                                objectStore.createIndex('layerZoom', ['layerId', 'zoomLevel'], { unique: false });
                                objectStore.createIndex('coordinate', ['tileX', 'tileY'], { unique: false });
                                objectStore.createIndex('fullIndex', ['layerId', 'zoomLevel', 'tileX', 'tileY'], { unique: true });
                                
                                console.log('å¯¹è±¡å­˜å‚¨åˆ›å»ºå®Œæˆ');
                            };
                        });
                    }

                    generateTileId(layerId, zoomLevel, tileX, tileY) {
                        return `${layerId}_${zoomLevel}_${tileX}_${tileY}`;
                    }

                    async getStore(mode = 'readonly') {
                        const db = await this.openDB();
                        const transaction = db.transaction([this.storeName], mode);
                        return transaction.objectStore(this.storeName);
                    }
                }

                class TileCacheService {
                    constructor() {
                        this.db = new TileCacheDB();
                    }

                    async getTile(layerId, zoomLevel, tileX, tileY) {
                        try {
                            const store = await this.db.getStore('readonly');
                            const id = this.db.generateTileId(layerId, zoomLevel, tileX, tileY);
                            
                            return new Promise((resolve, reject) => {
                                const request = store.get(id);
                                request.onsuccess = () => resolve(request.result);
                                request.onerror = () => reject(request.error);
                            });
                        } catch (error) {
                            console.error('è·å–ç“¦ç‰‡å¤±è´¥:', error);
                            return null;
                        }
                    }

                    async getAllTiles() {
                        try {
                            const store = await this.db.getStore('readonly');
                            
                            return new Promise((resolve, reject) => {
                                const request = store.getAll();
                                request.onsuccess = () => {
                                    console.log(`IndexedDB getAll() è¿”å› ${request.result.length} æ¡è®°å½•`);
                                    resolve(request.result);
                                };
                                request.onerror = () => {
                                    console.error('getAll() è¯·æ±‚å¤±è´¥:', request.error);
                                    reject(request.error);
                                };
                            });
                        } catch (error) {
                            console.error('è·å–æ‰€æœ‰ç“¦ç‰‡å¤±è´¥:', error);
                            return [];
                        }
                    }

                    async getCacheStats() {
                        try {
                            const tiles = await this.getAllTiles();
                            const layers = new Set();
                            let totalSize = 0;
                            let lastUpdate = 0;

                            tiles.forEach(tile => {
                                layers.add(tile.layerId);
                                totalSize += tile.size || 0;
                                lastUpdate = Math.max(lastUpdate, tile.timestamp || 0);
                            });

                            return {
                                totalTiles: tiles.length,
                                layerCount: layers.size,
                                totalSize,
                                lastUpdate
                            };
                        } catch (error) {
                            console.error('è·å–ç¼“å­˜ç»Ÿè®¡å¤±è´¥:', error);
                            return {
                                totalTiles: 0,
                                layerCount: 0,
                                totalSize: 0,
                                lastUpdate: 0
                            };
                        }
                    }

                    async getLayerTiles(layerId) {
                        try {
                            const store = await this.db.getStore('readonly');
                            const index = store.index('layerId');
                            
                            return new Promise((resolve, reject) => {
                                const request = index.getAll(layerId);
                                request.onsuccess = () => resolve(request.result);
                                request.onerror = () => reject(request.error);
                            });
                        } catch (error) {
                            console.error('è·å–å›¾å±‚ç“¦ç‰‡å¤±è´¥:', error);
                            return [];
                        }
                    }

                    async saveTile(tileData) {
                        try {
                            const store = await this.db.getStore('readwrite');
                            
                            return new Promise((resolve, reject) => {
                                const request = store.put(tileData);
                                request.onsuccess = () => {
                                    console.log(`ç“¦ç‰‡ä¿å­˜æˆåŠŸ: ${tileData.id}`);
                                    resolve(request.result);
                                };
                                request.onerror = () => {
                                    console.error(`ç“¦ç‰‡ä¿å­˜å¤±è´¥: ${tileData.id}`, request.error);
                                    reject(request.error);
                                };
                            });
                        } catch (error) {
                            console.error('ä¿å­˜ç“¦ç‰‡å¤±è´¥:', error);
                            throw error;
                        }
                    }
                }

                tileCacheService = new TileCacheService();
                await tileCacheService.db.openDB();
                console.log('ç¼“å­˜æœåŠ¡åˆå§‹åŒ–å®Œæˆï¼Œä½¿ç”¨ä¸å‰ç«¯ä¸€è‡´çš„æ•°æ®åº“æ“ä½œ');
            } catch (error) {
                console.error('ç¼“å­˜æœåŠ¡åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // æ£€æŸ¥ç¼“å­˜æ•°æ®
        async function checkCachedData() {
            try {
                console.log('å¼€å§‹æ£€æŸ¥ IndexedDB æ•°æ®åº“ç»“æ„...');
                
                // å…ˆæ£€æŸ¥æ•°æ®åº“ç»“æ„
                await checkDatabaseStructure();
                
                // ä½¿ç”¨æ­£ç¡®çš„æ–¹æ³•è·å–æ‰€æœ‰ç“¦ç‰‡
                console.log('è°ƒç”¨ tileCacheService.getAllTiles()...');
                const allTiles = await tileCacheService.getAllTiles();
                console.log(`ç¼“å­˜ä¸­å…±æœ‰ ${allTiles.length} ä¸ªç“¦ç‰‡è®°å½•`);
                
                if (allTiles.length === 0) {
                    console.log('ç¼“å­˜ä¸ºç©º');
                    
                    // é¢å¤–è°ƒè¯•ï¼šç›´æ¥æŸ¥è¯¢æ•°æ®åº“
                    console.log('è¿›è¡Œé¢å¤–çš„ç›´æ¥æ•°æ®åº“æŸ¥è¯¢...');
                    await directDatabaseQuery();
                    
                    return { layerIds: [], totalTiles: 0, format: 'structured' };
                }
                
                // åˆ†ææ•°æ®ç»“æ„
                const sampleRecord = allTiles[0];
                console.log('ç¤ºä¾‹è®°å½•ç»“æ„:', sampleRecord);
                console.log('è®°å½•å­—æ®µ:', Object.keys(sampleRecord));
                
                // æŒ‰å›¾å±‚åˆ†ç»„æ˜¾ç¤º
                const layerGroups = {};
                
                allTiles.forEach(tile => {
                    const layerId = tile.layerId;
                    const z = tile.zoomLevel;
                    const x = tile.tileX;
                    const y = tile.tileY;
                    
                    if (!layerGroups[layerId]) {
                        layerGroups[layerId] = [];
                    }
                    layerGroups[layerId].push(`${z}/${x}/${y}`);
                });
                
                const layerIds = Object.keys(layerGroups);
                console.log(`å‘ç° ${layerIds.length} ä¸ªå›¾å±‚:`);
                
                Object.keys(layerGroups).forEach(layerId => {
                    console.log(`å›¾å±‚ ${layerId}: ${layerGroups[layerId].length} ä¸ªç“¦ç‰‡`);
                    console.log(`ç“¦ç‰‡åˆ—è¡¨:`, layerGroups[layerId].slice(0, 5), layerGroups[layerId].length > 5 ? '...' : '');
                });
                
                // è·å–ç¼“å­˜ç»Ÿè®¡
                const stats = await tileCacheService.getCacheStats();
                console.log('ç¼“å­˜ç»Ÿè®¡:', stats);
                
                return { layerIds, totalTiles: allTiles.length, format: 'structured', stats };
                
            } catch (error) {
                console.error('æ£€æŸ¥ç¼“å­˜æ•°æ®å¤±è´¥:', error);
                return { layerIds: [], totalTiles: 0, format: 'structured' };
            }
        }

        // ç›´æ¥æ•°æ®åº“æŸ¥è¯¢è°ƒè¯•
        async function directDatabaseQuery() {
            try {
                console.log('=== ç›´æ¥æ•°æ®åº“æŸ¥è¯¢è°ƒè¯• ===');
                
                const db = await tileCacheService.db.openDB();
                console.log('æ•°æ®åº“å¯¹è±¡:', db);
                console.log('æ•°æ®åº“ç‰ˆæœ¬:', db.version);
                console.log('å¯¹è±¡å­˜å‚¨åç§°:', Array.from(db.objectStoreNames));
                
                if (db.objectStoreNames.contains('tiles')) {
                    console.log('å°è¯•ç›´æ¥ä» tiles å­˜å‚¨è·å–æ•°æ®...');
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['tiles'], 'readonly');
                        const store = transaction.objectStore('tiles');
                        
                        // ä½¿ç”¨ count() è·å–è®°å½•æ•°
                        const countRequest = store.count();
                        countRequest.onsuccess = () => {
                            console.log(`ç›´æ¥æŸ¥è¯¢è®°å½•æ•°: ${countRequest.result}`);
                        };
                        
                        // ä½¿ç”¨ openCursor() éå†æ‰€æœ‰è®°å½•
                        const cursorRequest = store.openCursor();
                        let recordCount = 0;
                        const samples = [];
                        
                        cursorRequest.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                recordCount++;
                                if (samples.length < 3) {
                                    samples.push(cursor.value);
                                }
                                cursor.continue();
                            } else {
                                console.log(`é€šè¿‡æ¸¸æ ‡ç»Ÿè®¡è®°å½•æ•°: ${recordCount}`);
                                console.log('å‰3æ¡è®°å½•æ ·æœ¬:', samples);
                                resolve();
                            }
                        };
                        
                        cursorRequest.onerror = () => {
                            console.error('æ¸¸æ ‡æŸ¥è¯¢å¤±è´¥:', cursorRequest.error);
                            resolve();
                        };
                        
                        transaction.onerror = () => {
                            console.error('äº‹åŠ¡å¤±è´¥:', transaction.error);
                            resolve();
                        };
                    });
                } else {
                    console.log('tiles å¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨');
                }
                
            } catch (error) {
                console.error('ç›´æ¥æ•°æ®åº“æŸ¥è¯¢å¤±è´¥:', error);
            }
        }

        // æ£€æŸ¥æ•°æ®åº“ç»“æ„
        async function checkDatabaseStructure() {
            return new Promise((resolve, reject) => {
                // æ‰“å¼€æ•°æ®åº“ä½†ä¸æŒ‡å®šç‰ˆæœ¬ï¼Œè·å–æ‰€æœ‰å­˜åœ¨çš„æ•°æ®åº“
                const request = indexedDB.open('TileCacheDB');
                
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    console.log(`æ•°æ®åº“ç‰ˆæœ¬: ${db.version}`);
                    console.log(`å¯¹è±¡å­˜å‚¨åˆ—è¡¨:`, Array.from(db.objectStoreNames));
                    
                    if (db.objectStoreNames.length === 0) {
                        console.log('æ•°æ®åº“ä¸­æ²¡æœ‰å¯¹è±¡å­˜å‚¨');
                    } else {
                        // æ£€æŸ¥æ¯ä¸ªå¯¹è±¡å­˜å‚¨
                        Array.from(db.objectStoreNames).forEach(storeName => {
                            console.log(`å‘ç°å¯¹è±¡å­˜å‚¨: ${storeName}`);
                        });
                    }
                    
                    db.close();
                    resolve();
                };
                
                request.onerror = () => {
                    console.log('æ•°æ®åº“ä¸å­˜åœ¨æˆ–æ— æ³•æ‰“å¼€');
                    resolve();
                };
                
                request.onupgradeneeded = (event) => {
                    console.log('æ•°æ®åº“éœ€è¦å‡çº§ï¼Œå¯èƒ½æ˜¯é¦–æ¬¡åˆ›å»º');
                    event.target.result.close();
                    resolve();
                };
            });
        }

        // æ£€æŸ¥ç¼“å­˜æ•°æ®åº“
        async function checkAllDatabases() {
            console.log('æ£€æŸ¥ç¼“å­˜æ•°æ®åº“...');
            
            try {
                console.log(`æ£€æŸ¥æ•°æ®åº“: TileCacheDB`);
                await checkSpecificDatabase('TileCacheDB');
                
                // åŒæ—¶æ˜¾ç¤ºæ ·æœ¬æ•°æ®
                await showSampleData();
            } catch (error) {
                console.log(`æ•°æ®åº“ TileCacheDB ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®:`, error);
            }
        }

        // æ£€æŸ¥ç‰¹å®šæ•°æ®åº“
        async function checkSpecificDatabase(dbName) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName);
                
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    console.log(`âœ“ æ•°æ®åº“ ${dbName} å­˜åœ¨, ç‰ˆæœ¬: ${db.version}`);
                    console.log(`  å¯¹è±¡å­˜å‚¨:`, Array.from(db.objectStoreNames));
                    
                    // æ£€æŸ¥æ¯ä¸ªå­˜å‚¨çš„æ•°æ®
                    Array.from(db.objectStoreNames).forEach(storeName => {
                        const transaction = db.transaction([storeName], 'readonly');
                        const store = transaction.objectStore(storeName);
                        const countRequest = store.count();
                        
                        countRequest.onsuccess = () => {
                            console.log(`  ${storeName}: ${countRequest.result} æ¡è®°å½•`);
                        };
                    });
                    
                    db.close();
                    resolve();
                };
                
                request.onerror = () => {
                    reject(new Error(`æ— æ³•æ‰“å¼€æ•°æ®åº“ ${dbName}`));
                };
            });
        }

        // åŠ è½½ç¼“å­˜æ•°æ®
        async function loadCachedData() {
            if (!tileCacheService) {
                document.getElementById('status').textContent = 'ç¼“å­˜æœåŠ¡æœªåˆå§‹åŒ–';
                return;
            }

            console.log('å¼€å§‹åŠ è½½ç¼“å­˜æ•°æ®...');
            document.getElementById('status').textContent = 'æ­£åœ¨åŠ è½½ç¼“å­˜æ•°æ®...';

            try {
                // é¦–å…ˆæ£€æŸ¥ç¼“å­˜ä¸­æœ‰ä»€ä¹ˆæ•°æ®
                const cacheInfo = await checkCachedData();
                
                if (cacheInfo.layerIds.length === 0) {
                    document.getElementById('status').textContent = 'ç¼“å­˜ä¸­æ²¡æœ‰æ•°æ®';
                    console.log('ç¼“å­˜ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å›¾å±‚æ•°æ®');
                    return;
                }
                
                // ä½¿ç”¨æ£€æµ‹åˆ°çš„ç¬¬ä¸€ä¸ªå›¾å±‚ID
                const layerId = cacheInfo.layerIds[0];
                console.log(`ä½¿ç”¨å›¾å±‚ID: ${layerId}`);
                
                // åˆ›å»º MVT æ ¼å¼è§£æå™¨
                const mvtFormat = new ol.format.MVT();

                // åˆ›å»ºçŸ¢é‡ç“¦ç‰‡æº
                const mvtSource = new ol.source.VectorTile({
                    format: mvtFormat,
                    tileGrid: ol.tilegrid.createXYZ({
                        maxZoom: 20,
                        minZoom: 0
                    }),
                    tileLoadFunction: function(tile) {
                        // ä½¿ç”¨ setLoader è®© OpenLayers æ­£ç¡®è§¦å‘æ¸²æŸ“æµç¨‹
                        tile.setLoader(function(extent, resolution, projection) {
                            const coords = tile.getTileCoord();
                            const [z, x, y] = [coords[0], coords[1], -coords[2] - 1];
                            console.log(`Loader è¯·æ±‚ç“¦ç‰‡: ${layerId} - ${z}/${x}/${y}`);

                            tileCacheService.getTile(layerId, z, x, y)
                                .then(cachedTile => {
                                    if (!cachedTile || !cachedTile.data) {
                                        tile.setFeatures([]);
                                        return;
                                    }

                                    let toArrayBuffer;
                                    if (cachedTile.data instanceof ArrayBuffer) {
                                        toArrayBuffer = Promise.resolve(cachedTile.data);
                                    } else if (cachedTile.data instanceof Blob) {
                                        toArrayBuffer = cachedTile.data.arrayBuffer();
                                    } else if (typeof cachedTile.data === 'string') {
                                        toArrayBuffer = Promise.resolve(base64ToArrayBuffer(cachedTile.data));
                                    } else {
                                        tile.setFeatures([]);
                                        return;
                                    }

                                    toArrayBuffer.then(buf => {
                                        const features = mvtFormat.readFeatures(buf, {
                                            extent,
                                            featureProjection: projection
                                        });
                                        tile.setFeatures(features);
                                    }).catch(err => {
                                        console.error('è§£æ MVT å¤±è´¥', err);
                                        tile.setFeatures([]);
                                    });
                                })
                                .catch(err => {
                                    console.error('åŠ è½½ç¼“å­˜ç“¦ç‰‡å¤±è´¥', err);
                                    tile.setFeatures([]);
                                });
                        });
                    }
                });

                // åˆ›å»ºçŸ¢é‡ç“¦ç‰‡å›¾å±‚
                mvtLayer = new ol.layer.VectorTile({
                    source: mvtSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#0000FF',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(0, 0, 255, 0.3)'
                        }),
                        image: new ol.style.Circle({
                            radius: 5,
                            fill: new ol.style.Fill({
                                color: '#FF0000'
                            })
                        })
                    })
                });

                // æ·»åŠ åˆ°åœ°å›¾
                map.addLayer(mvtLayer);
                
                // è°ƒæ•´è§†å›¾åˆ°æ•°æ®èŒƒå›´
                const extent = ol.proj.transformExtent(
                    [106.25894464801621, 31.59469451854329, 106.30545857841007, 31.61905294024268],
                    'EPSG:4326',
                    'EPSG:3857'
                );
                
                map.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 1000
                });

                console.log('MVT å›¾å±‚å·²æ·»åŠ åˆ°åœ°å›¾');

            } catch (error) {
                console.error('åŠ è½½ç¼“å­˜æ•°æ®å¤±è´¥:', error);
                document.getElementById('status').textContent = 'åŠ è½½å¤±è´¥: ' + error.message;
            }
        }

        // æ¸…é™¤å›¾å±‚
        function clearMap() {
            if (mvtLayer) {
                map.removeLayer(mvtLayer);
                mvtLayer = null;
                console.log('å·²æ¸…é™¤ MVT å›¾å±‚');
                document.getElementById('status').textContent = 'å·²æ¸…é™¤å›¾å±‚';
            }
        }

        // æ˜¾ç¤ºåœ°å›¾ä¿¡æ¯
        function showMapInfo() {
            const view = map.getView();
            const center = ol.proj.toLonLat(view.getCenter());
            const zoom = view.getZoom();
            
            console.log('åœ°å›¾ä¸­å¿ƒ:', center);
            console.log('ç¼©æ”¾çº§åˆ«:', zoom);
            console.log('å›¾å±‚æ•°é‡:', map.getLayers().getLength());
            
            document.getElementById('status').textContent = 
                `ä¸­å¿ƒ: [${center[0].toFixed(6)}, ${center[1].toFixed(6)}], ç¼©æ”¾: ${zoom.toFixed(1)}`;
        }

        // å¼ºåˆ¶åˆ·æ–°ç“¦ç‰‡
        function forceRefresh() {
            if (mvtLayer) {
                console.log('å¼ºåˆ¶åˆ·æ–° MVT å›¾å±‚...');
                mvtLayer.getSource().refresh();
                document.getElementById('status').textContent = 'å·²å¼ºåˆ¶åˆ·æ–°ç“¦ç‰‡';
            } else {
                document.getElementById('status').textContent = 'æ²¡æœ‰å›¾å±‚éœ€è¦åˆ·æ–°';
            }
        }

        // é‡æ–°åˆå§‹åŒ–æ•°æ®åº“
        async function reinitializeDB() {
            try {
                console.log('æ­£åœ¨é‡æ–°åˆå§‹åŒ–æ•°æ®åº“...');
                document.getElementById('status').textContent = 'æ­£åœ¨é‡æ–°åˆå§‹åŒ–æ•°æ®åº“...';
                
                // å…³é—­ç°æœ‰è¿æ¥
                if (tileCacheService && tileCacheService.db) {
                    tileCacheService.db.close();
                }
                
                // åˆ é™¤æ•°æ®åº“
                await new Promise((resolve, reject) => {
                    const deleteRequest = indexedDB.deleteDatabase('TileCacheDB');
                    deleteRequest.onsuccess = () => {
                        console.log('æ•°æ®åº“å·²åˆ é™¤');
                        resolve();
                    };
                    deleteRequest.onerror = () => reject(deleteRequest.error);
                });
                
                // é‡æ–°åˆå§‹åŒ–ç¼“å­˜æœåŠ¡
                await initCacheService();
                
                console.log('æ•°æ®åº“é‡æ–°åˆå§‹åŒ–å®Œæˆ');
                document.getElementById('status').textContent = 'æ•°æ®åº“é‡æ–°åˆå§‹åŒ–å®Œæˆ';
                
            } catch (error) {
                console.error('é‡æ–°åˆå§‹åŒ–æ•°æ®åº“å¤±è´¥:', error);
                document.getElementById('status').textContent = 'é‡æ–°åˆå§‹åŒ–å¤±è´¥: ' + error.message;
            }
        }

        // æ˜¾ç¤ºæ ·æœ¬æ•°æ®
        async function showSampleData() {
            try {
                const allTiles = await tileCacheService.getAllTiles();
                if (allTiles.length === 0) {
                    console.log('ç¼“å­˜ä¸­æ²¡æœ‰æ•°æ®');
                    document.getElementById('status').textContent = 'ç¼“å­˜ä¸­æ²¡æœ‰æ•°æ®';
                    
                    // è¿›è¡Œç›´æ¥æ•°æ®åº“æŸ¥è¯¢
                    await directDatabaseQuery();
                    return;
                }
                
                console.log('=== ç¼“å­˜æ•°æ®æ ·æœ¬ ===');
                console.log(`æ€»è®°å½•æ•°: ${allTiles.length}`);
                console.log('å‰3æ¡è®°å½•:');
                allTiles.slice(0, 3).forEach((record, index) => {
                    console.log(`è®°å½• ${index + 1}:`, record);
                });
                
                // è·å–ç¼“å­˜ç»Ÿè®¡
                const stats = await tileCacheService.getCacheStats();
                console.log('ç¼“å­˜ç»Ÿè®¡:', stats);
                
                document.getElementById('status').textContent = `æ˜¾ç¤ºäº†å‰3æ¡è®°å½•ï¼Œæ€»å…±${allTiles.length}æ¡è®°å½•`;
            } catch (error) {
                console.error('æ˜¾ç¤ºæ ·æœ¬æ•°æ®å¤±è´¥:', error);
                document.getElementById('status').textContent = 'æ˜¾ç¤ºæ ·æœ¬æ•°æ®å¤±è´¥';
            }
        }

        // é€‰æ‹©ç‰¹å®šå›¾å±‚åŠ è½½
        async function loadSpecificLayer() {
            try {
                const cacheInfo = await checkCachedData();
                
                if (cacheInfo.layerIds.length === 0) {
                    alert('ç¼“å­˜ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å›¾å±‚æ•°æ®');
                    return;
                }
                
                let layerList = 'å¯ç”¨å›¾å±‚:\n';
                cacheInfo.layerIds.forEach((layerId, index) => {
                    layerList += `${index + 1}. ${layerId}\n`;
                });
                
                const choice = prompt(layerList + '\nè¯·è¾“å…¥è¦åŠ è½½çš„å›¾å±‚ç¼–å· (1-' + cacheInfo.layerIds.length + '):');
                
                if (choice && !isNaN(choice)) {
                    const index = parseInt(choice) - 1;
                    if (index >= 0 && index < cacheInfo.layerIds.length) {
                        const selectedLayerId = cacheInfo.layerIds[index];
                        console.log(`é€‰æ‹©åŠ è½½å›¾å±‚: ${selectedLayerId}`);
                        
                        // æ¸…é™¤ç°æœ‰å›¾å±‚
                        if (mvtLayer) {
                            map.removeLayer(mvtLayer);
                        }
                        
                        // åŠ è½½é€‰ä¸­çš„å›¾å±‚
                        await loadLayerById(selectedLayerId);
                    } else {
                        alert('æ— æ•ˆçš„å›¾å±‚ç¼–å·');
                    }
                }
            } catch (error) {
                console.error('é€‰æ‹©å›¾å±‚å¤±è´¥:', error);
                alert('é€‰æ‹©å›¾å±‚å¤±è´¥: ' + error.message);
            }
        }

        // æŒ‰å›¾å±‚IDåŠ è½½æ•°æ®
        async function loadLayerById(layerId) {
            console.log(`å¼€å§‹åŠ è½½å›¾å±‚: ${layerId}`);
            document.getElementById('status').textContent = `æ­£åœ¨åŠ è½½å›¾å±‚: ${layerId}`;

            try {
                // åˆ›å»º MVT æ ¼å¼è§£æå™¨
                const mvtFormat = new ol.format.MVT();

                // åˆ›å»ºçŸ¢é‡ç“¦ç‰‡æº
                const mvtSource = new ol.source.VectorTile({
                    format: mvtFormat,
                    tileGrid: ol.tilegrid.createXYZ({
                        maxZoom: 20,
                        minZoom: 0
                    }),
                    tileLoadFunction: function(tile) {
                        tile.setLoader(function(extent, resolution, projection) {
                            const coords = tile.getTileCoord();
                            const [z, x, y] = [coords[0], coords[1], -coords[2] - 1];
                            console.log(`Loader è¯·æ±‚ç“¦ç‰‡: ${layerId} - ${z}/${x}/${y}`);

                            tileCacheService.getTile(layerId, z, x, y)
                                .then(cachedTile => {
                                    if (!cachedTile || !cachedTile.data) {
                                        tile.setFeatures([]);
                                        return;
                                    }

                                    let toArrayBuffer;
                                    if (cachedTile.data instanceof ArrayBuffer) {
                                        toArrayBuffer = Promise.resolve(cachedTile.data);
                                    } else if (cachedTile.data instanceof Blob) {
                                        toArrayBuffer = cachedTile.data.arrayBuffer();
                                    } else if (typeof cachedTile.data === 'string') {
                                        toArrayBuffer = Promise.resolve(base64ToArrayBuffer(cachedTile.data));
                                    } else {
                                        tile.setFeatures([]);
                                        return;
                                    }

                                    toArrayBuffer.then(buf => {
                                        const features = mvtFormat.readFeatures(buf, {
                                            extent,
                                            featureProjection: projection
                                        });
                                        tile.setFeatures(features);
                                    }).catch(err => {
                                        console.error('è§£æ MVT å¤±è´¥', err);
                                        tile.setFeatures([]);
                                    });
                                })
                                .catch(err => {
                                    console.error('åŠ è½½ç¼“å­˜ç“¦ç‰‡å¤±è´¥', err);
                                    tile.setFeatures([]);
                                });
                        });
                    }
                });

                // åˆ›å»ºçŸ¢é‡ç“¦ç‰‡å›¾å±‚
                mvtLayer = new ol.layer.VectorTile({
                    source: mvtSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#0000FF',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(0, 0, 255, 0.3)'
                        }),
                        image: new ol.style.Circle({
                            radius: 5,
                            fill: new ol.style.Fill({
                                color: '#FF0000'
                            })
                        })
                    })
                });

                // æ·»åŠ åˆ°åœ°å›¾
                map.addLayer(mvtLayer);
                
                // è°ƒæ•´è§†å›¾åˆ°æ•°æ®èŒƒå›´ï¼ˆå¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ï¼‰
                const extent = ol.proj.transformExtent(
                    [106.25, 31.55, 106.35, 31.65],
                    'EPSG:4326',
                    'EPSG:3857'
                );
                
                map.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 1000
                });

                console.log(`MVT å›¾å±‚ ${layerId} å·²æ·»åŠ åˆ°åœ°å›¾`);

            } catch (error) {
                console.error('åŠ è½½å›¾å±‚å¤±è´¥:', error);
                document.getElementById('status').textContent = 'åŠ è½½å¤±è´¥: ' + error.message;
            }
        }

        // æ£€æŸ¥é¡µé¢æºä¿¡æ¯
        function checkOriginInfo() {
            const currentOrigin = window.location.origin;
            const currentUrl = window.location.href;
            
            document.getElementById('current-origin').textContent = currentOrigin;
            
            console.log('=== é¡µé¢æºä¿¡æ¯ ===');
            console.log('å½“å‰æº:', currentOrigin);
            console.log('å½“å‰URL:', currentUrl);
            console.log('åè®®:', window.location.protocol);
            console.log('ä¸»æœº:', window.location.host);
            console.log('ç«¯å£:', window.location.port);
            
            // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨æ–‡ä»¶åè®®
            if (window.location.protocol === 'file:') {
                console.warn('âš ï¸ è­¦å‘Šï¼šæ‚¨æ­£åœ¨ä½¿ç”¨æ–‡ä»¶åè®®è®¿é—®æ­¤é¡µé¢ï¼');
                console.warn('IndexedDB æ•°æ®å°†ä¸ Vue åº”ç”¨éš”ç¦»ã€‚');
                console.warn('è¯·é€šè¿‡ Vue å¼€å‘æœåŠ¡å™¨è®¿é—®æ­¤é¡µé¢ï¼š');
                console.warn('ä¾‹å¦‚ï¼šhttp://localhost:8080/test-mvt-cache.html');
                
                document.getElementById('status').textContent = 'è­¦å‘Šï¼šæ–‡ä»¶åè®®æ¨¡å¼ï¼Œæ•°æ®åº“éš”ç¦»';
                document.getElementById('status').style.color = 'red';
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦å¯èƒ½æ˜¯æ­£ç¡®çš„å¼€å‘ç¯å¢ƒ
            if (currentOrigin.includes('localhost') || currentOrigin.includes('127.0.0.1')) {
                console.log('âœ“ æ£€æµ‹åˆ°æœ¬åœ°å¼€å‘ç¯å¢ƒ');
                return true;
            }
            
            console.log('â„¹ï¸ ç”Ÿäº§ç¯å¢ƒæˆ–å…¶ä»–ç¯å¢ƒ');
            return true;
        }

        // æ·»åŠ æ•°æ®åº“æºæ£€æŸ¥
        async function checkDatabaseOrigin() {
            try {
                console.log('=== æ•°æ®åº“æºæ£€æŸ¥ ===');
                
                // åˆ—å‡ºæ‰€æœ‰å¯èƒ½çš„æ•°æ®åº“ï¼ˆè¿™éœ€è¦ç”¨æˆ·æƒé™ï¼Œå¯èƒ½ä¸ä¼šæˆåŠŸï¼‰
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    console.log('å­˜å‚¨ä¼°ç®—:', estimate);
                }
                
                // å°è¯•æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æºçš„ IndexedDB
                console.log('IndexedDB æ”¯æŒ:', !!window.indexedDB);
                
                return true;
            } catch (error) {
                console.error('æ•°æ®åº“æºæ£€æŸ¥å¤±è´¥:', error);
                return false;
            }
        }

        // æ·»åŠ ç¯å¢ƒæ£€æŸ¥åŠŸèƒ½
        async function checkEnvironment() {
            console.log('=== ç¯å¢ƒæ£€æŸ¥ ===');
            
            const isValidOrigin = checkOriginInfo();
            await checkDatabaseOrigin();
            
            if (!isValidOrigin) {
                const helpInfo = document.createElement('div');
                helpInfo.style.cssText = 'background: #ffe6e6; border: 1px solid #ff9999; padding: 10px; margin: 10px 0; border-radius: 4px;';
                helpInfo.innerHTML = `
                    <h4>ğŸ“‹ å¦‚ä½•æ­£ç¡®è®¿é—®æ­¤æµ‹è¯•é¡µé¢ï¼š</h4>
                    <ol>
                        <li>ç¡®ä¿ Vue å¼€å‘æœåŠ¡å™¨æ­£åœ¨è¿è¡Œ: <code>npm run serve</code></li>
                        <li>é€šè¿‡å¼€å‘æœåŠ¡å™¨è®¿é—®: <code>http://localhost:8080/test-mvt-cache.html</code></li>
                        <li>æˆ–è€…å°†æ­¤æ–‡ä»¶ç§»åŠ¨åˆ° Vue é¡¹ç›®çš„ public ç›®å½•ä¸­</li>
                    </ol>
                    <p><strong>å½“å‰é—®é¢˜:</strong> æ–‡ä»¶åè®®ä¸ Vue åº”ç”¨çš„ IndexedDB æ•°æ®åº“éš”ç¦»</p>
                `;
                document.body.insertBefore(helpInfo, document.getElementById('map'));
            }
            
            return isValidOrigin;
        }

        // æ‰“å¼€ Vue åº”ç”¨
        function openVueApp() {
            const currentHost = window.location.host;
            const currentProtocol = window.location.protocol;
            
            // å°è¯•å¸¸è§çš„ Vue å¼€å‘æœåŠ¡å™¨ç«¯å£
            const commonPorts = ['8080', '3000', '4000', '5000', '8000'];
            
            if (window.location.port && !commonPorts.includes(window.location.port)) {
                commonPorts.unshift(window.location.port);
            }
            
            console.log('å°è¯•æ‰“å¼€ Vue åº”ç”¨çš„å¯èƒ½åœ°å€:');
            
            commonPorts.forEach(port => {
                const vueUrl = `${currentProtocol}//${window.location.hostname}:${port}`;
                console.log(`- ${vueUrl}`);
            });
            
            // é»˜è®¤å°è¯• 8080 ç«¯å£
            const defaultVueUrl = `${currentProtocol}//${window.location.hostname}:8080`;
            
            // è¯¢é—®ç”¨æˆ·æ˜¯å¦è¦æ‰“å¼€
            if (confirm(`æ˜¯å¦åœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€ Vue åº”ç”¨ï¼Ÿ\n\næ¨èåœ°å€: ${defaultVueUrl}\n\nç„¶ååœ¨ Vue åº”ç”¨ä¸­ä½¿ç”¨ç¼“å­˜ç®¡ç†åŠŸèƒ½åˆ›å»ºä¸€äº›ç¼“å­˜æ•°æ®ã€‚`)) {
                window.open(defaultVueUrl, '_blank');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = async function() {
            // å…ˆæ£€æŸ¥ç¯å¢ƒ
            const isValidEnvironment = await checkEnvironment();
            
            // åˆå§‹åŒ–åœ°å›¾
            initMap();
            
            // åˆå§‹åŒ–ç¼“å­˜æœåŠ¡
            await initCacheService();
            
            if (!isValidEnvironment) {
                document.getElementById('status').textContent += ' - å¯èƒ½æ— æ³•è®¿é—® Vue åº”ç”¨çš„ç¼“å­˜æ•°æ®';
            }
        };
    </script>
</body>
</html> 